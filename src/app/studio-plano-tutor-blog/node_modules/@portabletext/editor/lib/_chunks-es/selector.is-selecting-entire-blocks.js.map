{"version":3,"file":"selector.is-selecting-entire-blocks.js","sources":["../../src/selectors/selector.get-selection-end-point.ts","../../src/selectors/selector.get-selected-spans.ts","../../src/selectors/selector.get-active-annotations.ts","../../src/selectors/selector.get-active-list-item.ts","../../src/selectors/selector.get-active-style.ts","../../src/selectors/selector.get-next-inline-object.ts","../../src/selectors/selector.get-caret-word-selection.ts","../../src/selectors/selector.get-focus-inline-object.ts","../../src/selectors/selector.get-selected-text-blocks.ts","../../src/selectors/selector.get-trimmed-selection.ts","../../src/selectors/selector.is-active-annotation.ts","../../src/selectors/selector.is-active-decorator.ts","../../src/selectors/selector.is-active-list-item.ts","../../src/selectors/selector.is-active-style.ts","../../src/selectors/selector.is-at-the-end-of-block.ts","../../src/selectors/selector.is-at-the-start-of-block.ts","../../src/selectors/selector.is-point-after-selection.ts","../../src/selectors/selector.is-point-before-selection.ts","../../src/selectors/selector.is-overlapping-selection.ts","../../src/selectors/selector.is-selecting-entire-blocks.ts"],"sourcesContent":["import type {EditorSelectionPoint} from '..'\nimport type {EditorSelector} from '../editor/editor-selector'\n\n/**\n * @public\n */\nexport const getSelectionEndPoint: EditorSelector<\n  EditorSelectionPoint | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  return snapshot.context.selection.backward\n    ? snapshot.context.selection.anchor\n    : snapshot.context.selection.focus\n}\n","import type {KeyedSegment, PortableTextSpan} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isSpan, isTextBlock} from '../internal-utils/parse-blocks'\nimport {\n  getBlockKeyFromSelectionPoint,\n  getChildKeyFromSelectionPoint,\n} from '../selection/selection-point'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\n\n/**\n * @public\n */\nexport const getSelectedSpans: EditorSelector<\n  Array<{\n    node: PortableTextSpan\n    path: [KeyedSegment, 'children', KeyedSegment]\n  }>\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedSpans: Array<{\n    node: PortableTextSpan\n    path: [KeyedSegment, 'children', KeyedSegment]\n  }> = []\n\n  const startPoint = getSelectionStartPoint(snapshot)\n  const endPoint = getSelectionEndPoint(snapshot)\n\n  if (!startPoint || !endPoint) {\n    return selectedSpans\n  }\n\n  const startBlockKey = getBlockKeyFromSelectionPoint(startPoint)\n  const endBlockKey = getBlockKeyFromSelectionPoint(endPoint)\n\n  if (!startBlockKey || !endBlockKey) {\n    return selectedSpans\n  }\n\n  const startSpanKey = getChildKeyFromSelectionPoint(startPoint)\n  const endSpanKey = getChildKeyFromSelectionPoint(endPoint)\n\n  let startBlockFound = false\n\n  for (const block of snapshot.context.value) {\n    if (block._key === startBlockKey) {\n      startBlockFound = true\n    }\n\n    if (!isTextBlock(snapshot.context, block)) {\n      continue\n    }\n\n    if (block._key === startBlockKey) {\n      for (const child of block.children) {\n        if (!isSpan(snapshot.context, child)) {\n          continue\n        }\n\n        if (startSpanKey && child._key === startSpanKey) {\n          if (startPoint.offset < child.text.length) {\n            selectedSpans.push({\n              node: child,\n              path: [{_key: block._key}, 'children', {_key: child._key}],\n            })\n          }\n\n          if (startSpanKey === endSpanKey) {\n            break\n          }\n\n          continue\n        }\n\n        if (endSpanKey && child._key === endSpanKey) {\n          if (endPoint.offset > 0) {\n            selectedSpans.push({\n              node: child,\n              path: [{_key: block._key}, 'children', {_key: child._key}],\n            })\n          }\n          break\n        }\n\n        if (selectedSpans.length > 0) {\n          selectedSpans.push({\n            node: child,\n            path: [{_key: block._key}, 'children', {_key: child._key}],\n          })\n        }\n      }\n\n      if (startBlockKey === endBlockKey) {\n        break\n      }\n\n      continue\n    }\n\n    if (block._key === endBlockKey) {\n      for (const child of block.children) {\n        if (!isSpan(snapshot.context, child)) {\n          continue\n        }\n\n        if (endSpanKey && child._key === endSpanKey) {\n          if (endPoint.offset > 0) {\n            selectedSpans.push({\n              node: child,\n              path: [{_key: block._key}, 'children', {_key: child._key}],\n            })\n          }\n          break\n        }\n\n        selectedSpans.push({\n          node: child,\n          path: [{_key: block._key}, 'children', {_key: child._key}],\n        })\n      }\n\n      break\n    }\n\n    if (startBlockFound) {\n      for (const child of block.children) {\n        if (!isSpan(snapshot.context, child)) {\n          continue\n        }\n\n        selectedSpans.push({\n          node: child,\n          path: [{_key: block._key}, 'children', {_key: child._key}],\n        })\n      }\n    }\n  }\n\n  return selectedSpans\n}\n","import type {PortableTextObject} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isTextBlock} from '../internal-utils/parse-blocks'\nimport {getSelectedSpans} from './selector.get-selected-spans'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\nimport {getFocusSpan, getSelectedBlocks} from './selectors'\n\n/**\n * @public\n */\nexport const getActiveAnnotations: EditorSelector<Array<PortableTextObject>> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedBlocks = getSelectedBlocks(snapshot)\n  const selectedSpans = getSelectedSpans(snapshot)\n  const focusSpan = getFocusSpan(snapshot)\n\n  if (selectedSpans.length === 0 || !focusSpan) {\n    return []\n  }\n\n  if (selectedSpans.length === 1 && isSelectionCollapsed(snapshot)) {\n    if (snapshot.context.selection.focus.offset === 0) {\n      return []\n    }\n    if (\n      snapshot.context.selection.focus.offset === focusSpan.node.text.length\n    ) {\n      return []\n    }\n  }\n\n  const activeAnnotations = snapshot.beta.activeAnnotations\n  const selectionMarkDefs = selectedBlocks.flatMap((block) =>\n    isTextBlock(snapshot.context, block.node)\n      ? (block.node.markDefs ?? [])\n      : [],\n  )\n\n  return selectionMarkDefs.filter((markDef) =>\n    activeAnnotations.includes(markDef._key),\n  )\n}\n","import type {PortableTextListBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isTextBlock} from '../internal-utils/parse-blocks'\nimport {getSelectedBlocks} from './selectors'\n\n/**\n * @public\n */\nexport const getActiveListItem: EditorSelector<\n  PortableTextListBlock['listItem'] | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const selectedBlocks = getSelectedBlocks(snapshot).map((block) => block.node)\n  const selectedTextBlocks = selectedBlocks.filter((block) =>\n    isTextBlock(snapshot.context, block),\n  )\n\n  const firstTextBlock = selectedTextBlocks.at(0)\n\n  if (!firstTextBlock) {\n    return undefined\n  }\n\n  const firstListItem = firstTextBlock.listItem\n\n  if (!firstListItem) {\n    return undefined\n  }\n\n  if (selectedTextBlocks.every((block) => block.listItem === firstListItem)) {\n    return firstListItem\n  }\n\n  return undefined\n}\n","import type {PortableTextTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isTextBlock} from '../internal-utils/parse-blocks'\nimport {getSelectedBlocks} from './selectors'\n\n/**\n * @public\n */\nexport const getActiveStyle: EditorSelector<PortableTextTextBlock['style']> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const selectedBlocks = getSelectedBlocks(snapshot).map((block) => block.node)\n  const selectedTextBlocks = selectedBlocks.filter((block) =>\n    isTextBlock(snapshot.context, block),\n  )\n\n  const firstTextBlock = selectedTextBlocks.at(0)\n\n  if (!firstTextBlock) {\n    return undefined\n  }\n\n  const firstStyle = firstTextBlock.style\n\n  if (!firstStyle) {\n    return undefined\n  }\n\n  if (selectedTextBlocks.every((block) => block.style === firstStyle)) {\n    return firstStyle\n  }\n\n  return undefined\n}\n","import {\n  isKeySegment,\n  type KeyedSegment,\n  type PortableTextObject,\n} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isSpan} from '../utils'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\nimport {getFocusTextBlock} from './selectors'\n\n/**\n * @public\n */\nexport const getNextInlineObject: EditorSelector<\n  | {\n      node: PortableTextObject\n      path: [KeyedSegment, 'children', KeyedSegment]\n    }\n  | undefined\n> = (snapshot) => {\n  const focusTextBlock = getFocusTextBlock(snapshot)\n  const selectionEndPoint = getSelectionEndPoint(snapshot)\n  const selectionEndPointChildKey =\n    selectionEndPoint && isKeySegment(selectionEndPoint.path[2])\n      ? selectionEndPoint.path[2]._key\n      : undefined\n\n  if (!focusTextBlock || !selectionEndPointChildKey) {\n    return undefined\n  }\n\n  let endPointChildFound = false\n  let inlineObject:\n    | {\n        node: PortableTextObject\n        path: [KeyedSegment, 'children', KeyedSegment]\n      }\n    | undefined\n\n  for (const child of focusTextBlock.node.children) {\n    if (child._key === selectionEndPointChildKey) {\n      endPointChildFound = true\n      continue\n    }\n\n    if (!isSpan(snapshot.context, child) && endPointChildFound) {\n      inlineObject = {\n        node: child,\n        path: [...focusTextBlock.path, 'children', {_key: child._key}],\n      }\n      break\n    }\n  }\n\n  return inlineObject\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelection} from '../types/editor'\nimport {\n  blockOffsetToSpanSelectionPoint,\n  getBlockEndPoint,\n  getBlockStartPoint,\n  spanSelectionPointToBlockOffset,\n} from '../utils'\nimport {getNextInlineObject} from './selector.get-next-inline-object'\nimport {getPreviousInlineObject} from './selector.get-previous-inline-object'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\nimport {getSelectionText} from './selector.get-selection-text'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\nimport {isSelectionExpanded} from './selector.is-selection-expanded'\nimport {getFocusTextBlock} from './selectors'\n\n/**\n * @public\n * Returns the selection of the of the word the caret is placed in.\n * Note: Only returns a word selection if the current selection is collapsed\n */\nexport const getCaretWordSelection: EditorSelector<EditorSelection> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return null\n  }\n\n  if (!isSelectionCollapsed(snapshot)) {\n    return null\n  }\n\n  const focusTextBlock = getFocusTextBlock(snapshot)\n  const selectionStartPoint = getSelectionStartPoint(snapshot)\n  const selectionStartOffset = selectionStartPoint\n    ? spanSelectionPointToBlockOffset({\n        context: snapshot.context,\n        selectionPoint: selectionStartPoint,\n      })\n    : undefined\n\n  if (!focusTextBlock || !selectionStartPoint || !selectionStartOffset) {\n    return null\n  }\n\n  const previousInlineObject = getPreviousInlineObject(snapshot)\n  const blockStartPoint = getBlockStartPoint({\n    context: snapshot.context,\n    block: focusTextBlock,\n  })\n  const textBefore = getSelectionText({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: previousInlineObject\n          ? {path: previousInlineObject.path, offset: 0}\n          : blockStartPoint,\n        focus: selectionStartPoint,\n      },\n    },\n  })\n  const textDirectlyBefore = textBefore.split(/\\s+/).at(-1)\n\n  const nextInlineObject = getNextInlineObject(snapshot)\n  const blockEndPoint = getBlockEndPoint({\n    context: snapshot.context,\n    block: focusTextBlock,\n  })\n  const textAfter = getSelectionText({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: selectionStartPoint,\n        focus: nextInlineObject\n          ? {path: nextInlineObject.path, offset: 0}\n          : blockEndPoint,\n      },\n    },\n  })\n  const textDirectlyAfter = textAfter.split(/\\s+/).at(0)\n\n  if (\n    (textDirectlyBefore === undefined || textDirectlyBefore === '') &&\n    (textDirectlyAfter === undefined || textDirectlyAfter === '')\n  ) {\n    return null\n  }\n\n  const caretWordStartOffset: BlockOffset = textDirectlyBefore\n    ? {\n        ...selectionStartOffset,\n        offset: selectionStartOffset.offset - textDirectlyBefore.length,\n      }\n    : selectionStartOffset\n  const caretWordEndOffset: BlockOffset = textDirectlyAfter\n    ? {\n        ...selectionStartOffset,\n        offset: selectionStartOffset.offset + textDirectlyAfter.length,\n      }\n    : selectionStartOffset\n\n  const caretWordStartSelectionPoint = blockOffsetToSpanSelectionPoint({\n    context: snapshot.context,\n    blockOffset: caretWordStartOffset,\n    direction: 'backward',\n  })\n  const caretWordEndSelectionPoint = blockOffsetToSpanSelectionPoint({\n    context: snapshot.context,\n    blockOffset: caretWordEndOffset,\n    direction: 'forward',\n  })\n\n  if (!caretWordStartSelectionPoint || !caretWordEndSelectionPoint) {\n    return null\n  }\n\n  const caretWordSelection = {\n    anchor: caretWordStartSelectionPoint,\n    focus: caretWordEndSelectionPoint,\n  }\n\n  return isSelectionExpanded({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: caretWordSelection,\n    },\n  })\n    ? caretWordSelection\n    : null\n}\n","import {\n  isPortableTextSpan,\n  type KeyedSegment,\n  type PortableTextObject,\n} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getFocusChild} from './selectors'\n\n/**\n * @public\n */\nexport const getFocusInlineObject: EditorSelector<\n  | {node: PortableTextObject; path: [KeyedSegment, 'children', KeyedSegment]}\n  | undefined\n> = (snapshot) => {\n  const focusChild = getFocusChild(snapshot)\n\n  return focusChild && !isPortableTextSpan(focusChild.node)\n    ? {node: focusChild.node, path: focusChild.path}\n    : undefined\n}\n","import type {KeyedSegment, PortableTextTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isTextBlock} from '../internal-utils/parse-blocks'\nimport {getBlockKeyFromSelectionPoint} from '../selection/selection-point'\nimport {getSelectionEndPoint, getSelectionStartPoint} from '../utils'\n\n/**\n * @public\n */\nexport const getSelectedTextBlocks: EditorSelector<\n  Array<{node: PortableTextTextBlock; path: [KeyedSegment]}>\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedTextBlocks: Array<{\n    node: PortableTextTextBlock\n    path: [KeyedSegment]\n  }> = []\n\n  const startPoint = getSelectionStartPoint(snapshot.context.selection)\n  const endPoint = getSelectionEndPoint(snapshot.context.selection)\n  const startBlockKey = getBlockKeyFromSelectionPoint(startPoint)\n  const endBlockKey = getBlockKeyFromSelectionPoint(endPoint)\n\n  if (!startBlockKey || !endBlockKey) {\n    return selectedTextBlocks\n  }\n\n  for (const block of snapshot.context.value) {\n    if (block._key === startBlockKey) {\n      if (isTextBlock(snapshot.context, block)) {\n        selectedTextBlocks.push({node: block, path: [{_key: block._key}]})\n      }\n\n      if (startBlockKey === endBlockKey) {\n        break\n      }\n      continue\n    }\n\n    if (block._key === endBlockKey) {\n      if (isTextBlock(snapshot.context, block)) {\n        selectedTextBlocks.push({node: block, path: [{_key: block._key}]})\n      }\n\n      break\n    }\n\n    if (selectedTextBlocks.length > 0) {\n      if (isTextBlock(snapshot.context, block)) {\n        selectedTextBlocks.push({node: block, path: [{_key: block._key}]})\n      }\n    }\n  }\n\n  return selectedTextBlocks\n}\n","import type {PortableTextSpan} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isSpan, isTextBlock} from '../internal-utils/parse-blocks'\nimport {\n  getBlockKeyFromSelectionPoint,\n  getChildKeyFromSelectionPoint,\n} from '../selection/selection-point'\nimport type {EditorSelection, EditorSelectionPoint} from '../types/editor'\nimport {\n  getSelectionEndPoint,\n  getSelectionStartPoint,\n  isEmptyTextBlock,\n} from '../utils'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\nimport {getFocusTextBlock} from './selectors'\n\n/**\n * @public\n */\nexport const getTrimmedSelection: EditorSelector<EditorSelection> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return snapshot.context.selection\n  }\n\n  const startPoint = getSelectionStartPoint(snapshot.context.selection)\n  const endPoint = getSelectionEndPoint(snapshot.context.selection)\n\n  const startBlockKey = getBlockKeyFromSelectionPoint(startPoint)\n  const startChildKey = getChildKeyFromSelectionPoint(startPoint)\n  const endBlockKey = getBlockKeyFromSelectionPoint(endPoint)\n  const endChildKey = getChildKeyFromSelectionPoint(endPoint)\n\n  if (!startBlockKey || !endBlockKey) {\n    return snapshot.context.selection\n  }\n\n  let startBlockFound = false\n  let adjustedStartPoint: EditorSelectionPoint | undefined\n  let trimStartPoint = false\n  let adjustedEndPoint: EditorSelectionPoint | undefined\n  let trimEndPoint = false\n  let previousPotentialEndpoint:\n    | {blockKey: string; span: PortableTextSpan}\n    | undefined\n\n  for (const block of snapshot.context.value) {\n    if (block._key === startBlockKey) {\n      startBlockFound = true\n\n      if (\n        isTextBlock(snapshot.context, block) &&\n        isEmptyTextBlock(snapshot.context, block)\n      ) {\n        continue\n      }\n    }\n\n    if (!startBlockFound) {\n      continue\n    }\n\n    if (!isTextBlock(snapshot.context, block)) {\n      continue\n    }\n\n    if (\n      block._key === endBlockKey &&\n      isEmptyTextBlock(snapshot.context, block)\n    ) {\n      break\n    }\n\n    for (const child of block.children) {\n      if (child._key === endChildKey) {\n        if (!isSpan(snapshot.context, child) || endPoint.offset === 0) {\n          adjustedEndPoint = previousPotentialEndpoint\n            ? {\n                path: [\n                  {_key: previousPotentialEndpoint.blockKey},\n                  'children',\n                  {_key: previousPotentialEndpoint.span._key},\n                ],\n                offset: previousPotentialEndpoint.span.text.length,\n              }\n            : undefined\n\n          trimEndPoint = true\n          break\n        }\n      }\n\n      if (trimStartPoint) {\n        const lonelySpan =\n          isSpan(snapshot.context, child) && block.children.length === 1\n\n        if (\n          (isSpan(snapshot.context, child) && child.text.length > 0) ||\n          lonelySpan\n        ) {\n          adjustedStartPoint = {\n            path: [{_key: block._key}, 'children', {_key: child._key}],\n            offset: 0,\n          }\n          previousPotentialEndpoint = {blockKey: block._key, span: child}\n          trimStartPoint = false\n        }\n\n        continue\n      }\n\n      if (child._key === startChildKey) {\n        if (!isSpan(snapshot.context, child)) {\n          trimStartPoint = true\n          continue\n        }\n\n        if (startPoint.offset === child.text.length) {\n          trimStartPoint = true\n          previousPotentialEndpoint =\n            child.text.length > 0\n              ? {blockKey: block._key, span: child}\n              : previousPotentialEndpoint\n          continue\n        }\n      }\n\n      previousPotentialEndpoint =\n        isSpan(snapshot.context, child) && child.text.length > 0\n          ? {blockKey: block._key, span: child}\n          : previousPotentialEndpoint\n    }\n\n    if (block._key === endBlockKey) {\n      break\n    }\n  }\n\n  const trimmedSelection = snapshot.context.selection.backward\n    ? {\n        anchor: trimEndPoint && adjustedEndPoint ? adjustedEndPoint : endPoint,\n        focus: adjustedStartPoint ?? startPoint,\n        backward: true,\n      }\n    : {\n        anchor: adjustedStartPoint ?? startPoint,\n        focus: trimEndPoint && adjustedEndPoint ? adjustedEndPoint : endPoint,\n      }\n\n  if (\n    isSelectionCollapsed({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: trimmedSelection,\n      },\n    })\n  ) {\n    const focusTextBlock = getFocusTextBlock({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: trimmedSelection,\n      },\n    })\n\n    if (\n      focusTextBlock &&\n      !isEmptyTextBlock(snapshot.context, focusTextBlock.node)\n    ) {\n      return null\n    }\n  }\n\n  return trimmedSelection\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {isTextBlock} from '../internal-utils/parse-blocks'\nimport {getSelectedBlocks} from './selectors'\n\n/**\n * @public\n */\nexport function isActiveAnnotation(\n  annotation: string,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    const selectedBlocks = getSelectedBlocks(snapshot)\n    const selectionMarkDefs = selectedBlocks.flatMap((block) =>\n      isTextBlock(snapshot.context, block.node)\n        ? (block.node.markDefs ?? [])\n        : [],\n    )\n    const activeMarkDefs = selectionMarkDefs.filter(\n      (markDef) =>\n        markDef._type === annotation &&\n        snapshot.beta.activeAnnotations.includes(markDef._key),\n    )\n\n    return activeMarkDefs.length > 0\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedSpans} from './selector.get-selected-spans'\nimport {isSelectionExpanded} from './selector.is-selection-expanded'\n\n/**\n * @public\n */\nexport function isActiveDecorator(decorator: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (isSelectionExpanded(snapshot)) {\n      const selectedSpans = getSelectedSpans(snapshot)\n\n      return (\n        selectedSpans.length > 0 &&\n        selectedSpans.every((span) => span.node.marks?.includes(decorator))\n      )\n    }\n\n    return snapshot.beta.activeDecorators.includes(decorator)\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getActiveListItem} from './selector.get-active-list-item'\n\n/**\n * @public\n */\nexport function isActiveListItem(listItem: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    const activeListItem = getActiveListItem(snapshot)\n\n    return activeListItem === listItem\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getActiveStyle} from './selector.get-active-style'\n\n/**\n * @public\n */\nexport function isActiveStyle(style: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    const activeStyle = getActiveStyle(snapshot)\n\n    return activeStyle === style\n  }\n}\n","import type {KeyedSegment, PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport * as utils from '../utils'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport function isAtTheEndOfBlock(block: {\n  node: PortableTextBlock\n  path: [KeyedSegment]\n}): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection || !isSelectionCollapsed(snapshot)) {\n      return false\n    }\n\n    const blockEndPoint = utils.getBlockEndPoint({\n      context: snapshot.context,\n      block,\n    })\n\n    return utils.isEqualSelectionPoints(\n      snapshot.context.selection.focus,\n      blockEndPoint,\n    )\n  }\n}\n","import type {KeyedSegment, PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport * as utils from '../utils'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport function isAtTheStartOfBlock(block: {\n  node: PortableTextBlock\n  path: [KeyedSegment]\n}): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection || !isSelectionCollapsed(snapshot)) {\n      return false\n    }\n\n    const blockStartPoint = utils.getBlockStartPoint({\n      context: snapshot.context,\n      block,\n    })\n\n    return utils.isEqualSelectionPoints(\n      snapshot.context.selection.focus,\n      blockStartPoint,\n    )\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {isTextBlock} from '../internal-utils/parse-blocks'\nimport {\n  getBlockKeyFromSelectionPoint,\n  getChildKeyFromSelectionPoint,\n} from '../selection/selection-point'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {getSelectionEndPoint} from '../utils'\n\n/**\n * @public\n */\nexport function isPointAfterSelection(\n  point: EditorSelectionPoint,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection) {\n      return false\n    }\n\n    const endPoint = getSelectionEndPoint(snapshot.context.selection)\n    const endBlockKey = getBlockKeyFromSelectionPoint(endPoint)\n    const endChildKey = getChildKeyFromSelectionPoint(endPoint)\n\n    const pointBlockKey = getBlockKeyFromSelectionPoint(point)\n    const pointChildKey = getChildKeyFromSelectionPoint(point)\n\n    if (!pointBlockKey || !endBlockKey) {\n      return false\n    }\n\n    let after = false\n\n    for (const block of snapshot.context.value) {\n      if (block._key === endBlockKey) {\n        if (block._key !== pointBlockKey) {\n          after = true\n          break\n        }\n\n        // Both the point and the selection end in this block\n\n        if (!isTextBlock(snapshot.context, block)) {\n          break\n        }\n\n        if (!pointChildKey || !endChildKey) {\n          break\n        }\n\n        for (const child of block.children) {\n          if (child._key === endChildKey) {\n            if (child._key !== pointChildKey) {\n              after = true\n              break\n            }\n\n            // Both the point and the selection end in this child\n\n            after = point.offset > endPoint.offset\n            break\n          }\n\n          if (child._key === pointChildKey) {\n            break\n          }\n        }\n      }\n\n      if (block._key === pointBlockKey) {\n        break\n      }\n    }\n\n    return after\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {isTextBlock} from '../internal-utils/parse-blocks'\nimport {\n  getBlockKeyFromSelectionPoint,\n  getChildKeyFromSelectionPoint,\n} from '../selection/selection-point'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {getSelectionStartPoint} from '../utils'\n\n/**\n * @public\n */\nexport function isPointBeforeSelection(\n  point: EditorSelectionPoint,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection) {\n      return false\n    }\n\n    const startPoint = getSelectionStartPoint(snapshot.context.selection)\n    const startBlockKey = getBlockKeyFromSelectionPoint(startPoint)\n    const startChildKey = getChildKeyFromSelectionPoint(startPoint)\n\n    const pointBlockKey = getBlockKeyFromSelectionPoint(point)\n    const pointChildKey = getChildKeyFromSelectionPoint(point)\n\n    if (!pointBlockKey || !startBlockKey) {\n      return false\n    }\n\n    let before = false\n\n    for (const block of snapshot.context.value) {\n      if (block._key === pointBlockKey) {\n        if (block._key !== startBlockKey) {\n          before = true\n          break\n        }\n\n        // Both the point and the selection start in this block\n\n        if (!isTextBlock(snapshot.context, block)) {\n          break\n        }\n\n        if (!pointChildKey || !startChildKey) {\n          break\n        }\n\n        for (const child of block.children) {\n          if (child._key === pointChildKey) {\n            if (child._key !== startChildKey) {\n              before = true\n              break\n            }\n\n            // Both the point and the selection start in this child\n\n            before = point.offset < startPoint.offset\n            break\n          }\n\n          if (child._key === startChildKey) {\n            break\n          }\n        }\n      }\n\n      if (block._key === startBlockKey) {\n        break\n      }\n    }\n\n    return before\n  }\n}\n","import type {EditorSelection} from '../types/editor'\nimport {isEqualSelectionPoints} from '../utils'\nimport type {EditorSelector} from './../editor/editor-selector'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\nimport {isPointAfterSelection} from './selector.is-point-after-selection'\nimport {isPointBeforeSelection} from './selector.is-point-before-selection'\n\n/**\n * @public\n */\nexport function isOverlappingSelection(\n  selection: EditorSelection,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!selection || !snapshot.context.selection) {\n      return false\n    }\n\n    const selectionStartPoint = getSelectionStartPoint({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection,\n      },\n    })\n    const selectionEndPoint = getSelectionEndPoint({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection,\n      },\n    })\n\n    const originalSelectionStartPoint = getSelectionStartPoint(snapshot)\n    const originalSelectionEndPoint = getSelectionEndPoint(snapshot)\n\n    if (\n      !selectionStartPoint ||\n      !selectionEndPoint ||\n      !originalSelectionStartPoint ||\n      !originalSelectionEndPoint\n    ) {\n      return false\n    }\n\n    const startPointBeforeSelection =\n      isPointBeforeSelection(selectionStartPoint)(snapshot)\n    const startPointAfterSelection =\n      isPointAfterSelection(selectionStartPoint)(snapshot)\n    const endPointBeforeSelection =\n      isPointBeforeSelection(selectionEndPoint)(snapshot)\n    const endPointAfterSelection =\n      isPointAfterSelection(selectionEndPoint)(snapshot)\n\n    const originalStartPointBeforeStartPoint = isPointBeforeSelection(\n      originalSelectionStartPoint,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionStartPoint,\n          focus: selectionStartPoint,\n        },\n      },\n    })\n    const originalStartPointAfterStartPoint = isPointAfterSelection(\n      originalSelectionStartPoint,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionStartPoint,\n          focus: selectionStartPoint,\n        },\n      },\n    })\n\n    const originalEndPointBeforeEndPoint = isPointBeforeSelection(\n      originalSelectionEndPoint,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionEndPoint,\n          focus: selectionEndPoint,\n        },\n      },\n    })\n    const originalEndPointAfterEndPoint = isPointAfterSelection(\n      originalSelectionEndPoint,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionEndPoint,\n          focus: selectionEndPoint,\n        },\n      },\n    })\n\n    const endPointEqualToOriginalStartPoint = isEqualSelectionPoints(\n      selectionEndPoint,\n      originalSelectionStartPoint,\n    )\n    const startPointEqualToOriginalEndPoint = isEqualSelectionPoints(\n      selectionStartPoint,\n      originalSelectionEndPoint,\n    )\n\n    if (endPointBeforeSelection && !endPointEqualToOriginalStartPoint) {\n      return false\n    }\n\n    if (startPointAfterSelection && !startPointEqualToOriginalEndPoint) {\n      return false\n    }\n\n    if (\n      !originalStartPointBeforeStartPoint &&\n      originalStartPointAfterStartPoint &&\n      !originalEndPointBeforeEndPoint &&\n      originalEndPointAfterEndPoint\n    ) {\n      return !endPointEqualToOriginalStartPoint\n    }\n\n    if (\n      originalStartPointBeforeStartPoint &&\n      !originalStartPointAfterStartPoint &&\n      originalEndPointBeforeEndPoint &&\n      !originalEndPointAfterEndPoint\n    ) {\n      return !startPointEqualToOriginalEndPoint\n    }\n\n    if (\n      !startPointAfterSelection ||\n      !startPointBeforeSelection ||\n      !endPointAfterSelection ||\n      !endPointBeforeSelection\n    ) {\n      return true\n    }\n\n    return false\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport * as utils from '../utils'\nimport {getSelectionEndBlock, getSelectionStartBlock} from './selectors'\n\n/**\n * @public\n */\nexport const isSelectingEntireBlocks: EditorSelector<boolean> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return false\n  }\n\n  const startPoint = snapshot.context.selection.backward\n    ? snapshot.context.selection.focus\n    : snapshot.context.selection.anchor\n  const endPoint = snapshot.context.selection.backward\n    ? snapshot.context.selection.anchor\n    : snapshot.context.selection.focus\n\n  const startBlock = getSelectionStartBlock(snapshot)\n  const endBlock = getSelectionEndBlock(snapshot)\n\n  if (!startBlock || !endBlock) {\n    return false\n  }\n\n  const startBlockStartPoint = utils.getBlockStartPoint({\n    context: snapshot.context,\n    block: startBlock,\n  })\n  const endBlockEndPoint = utils.getBlockEndPoint({\n    context: snapshot.context,\n    block: endBlock,\n  })\n\n  return (\n    utils.isEqualSelectionPoints(startBlockStartPoint, startPoint) &&\n    utils.isEqualSelectionPoints(endBlockEndPoint, endPoint)\n  )\n}\n"],"names":["getSelectionEndPoint","snapshot","context","selection","backward","anchor","focus","getSelectedSpans","selectedSpans","startPoint","getSelectionStartPoint","endPoint","startBlockKey","getBlockKeyFromSelectionPoint","endBlockKey","startSpanKey","getChildKeyFromSelectionPoint","endSpanKey","startBlockFound","block","value","_key","isTextBlock","child","children","isSpan","offset","text","length","push","node","path","getActiveAnnotations","selectedBlocks","getSelectedBlocks","focusSpan","getFocusSpan","isSelectionCollapsed","activeAnnotations","beta","flatMap","markDefs","filter","markDef","includes","getActiveListItem","selectedTextBlocks","map","firstTextBlock","at","firstListItem","listItem","every","getActiveStyle","firstStyle","style","getNextInlineObject","focusTextBlock","getFocusTextBlock","selectionEndPoint","selectionEndPointChildKey","isKeySegment","undefined","endPointChildFound","inlineObject","getCaretWordSelection","selectionStartPoint","selectionStartOffset","spanSelectionPointToBlockOffset","selectionPoint","previousInlineObject","getPreviousInlineObject","blockStartPoint","getBlockStartPoint","textDirectlyBefore","getSelectionText","split","nextInlineObject","blockEndPoint","getBlockEndPoint","textDirectlyAfter","caretWordStartOffset","caretWordEndOffset","caretWordStartSelectionPoint","blockOffsetToSpanSelectionPoint","blockOffset","direction","caretWordEndSelectionPoint","caretWordSelection","isSelectionExpanded","getFocusInlineObject","focusChild","getFocusChild","isPortableTextSpan","getSelectedTextBlocks","getTrimmedSelection","startChildKey","endChildKey","adjustedStartPoint","trimStartPoint","adjustedEndPoint","trimEndPoint","previousPotentialEndpoint","isEmptyTextBlock","blockKey","span","lonelySpan","trimmedSelection","isActiveAnnotation","annotation","_type","isActiveDecorator","decorator","marks","activeDecorators","isActiveListItem","isActiveStyle","isAtTheEndOfBlock","utils","isAtTheStartOfBlock","isPointAfterSelection","point","pointBlockKey","pointChildKey","after","isPointBeforeSelection","before","isOverlappingSelection","originalSelectionStartPoint","originalSelectionEndPoint","startPointBeforeSelection","startPointAfterSelection","endPointBeforeSelection","endPointAfterSelection","originalStartPointBeforeStartPoint","originalStartPointAfterStartPoint","originalEndPointBeforeEndPoint","originalEndPointAfterEndPoint","endPointEqualToOriginalStartPoint","isEqualSelectionPoints","startPointEqualToOriginalEndPoint","isSelectingEntireBlocks","startBlock","getSelectionStartBlock","endBlock","getSelectionEndBlock","startBlockStartPoint","endBlockEndPoint"],"mappings":"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"}